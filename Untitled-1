
#[derive(Clone, Debug, Serialize, Deserialize, Default)]
struct PartyInfo {
    pub id: Uuid,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub leader: Uuid,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub members: Vec<Uuid>,
}

#[derive(Clone)]
struct PartyInfoStore {
    pool: deadpool_redis::Pool,
}

impl PartyInfoStore {
    pub fn new(pool: deadpool_redis::Pool) -> Self {
        Self { pool }
    }

    pub async fn create_party(
        &self,
        party_id: Uuid,
        leader_id: Uuid,
        name: Option<String>,
    ) -> Result<()> {
        let info_key = keys::party::info(party_id);
        let members_key = keys::party::members(party_id);
        let mut conn = self
            .pool
            .get()
            .await
            .context("Failed to get Redis connection")?;
        let mut pipe = redis::pipe();
        pipe.atomic()
            .hset(&info_key, "leader", leader_id.to_string());
        if let Some(name) = name {
            pipe.hset(&info_key, "name", name);
        } else {
            pipe.hdel(&info_key, "name");
        }
        pipe.expire(&info_key, EXPIRE_SECONDS)
            .sadd(&members_key, leader_id.to_string())
            .expire(&members_key, EXPIRE_SECONDS);
        let _: () = pipe
            .query_async(&mut conn)
            .await
            .context("Failed to create party in Redis")?;
        if let Err(e) = conn
            .set::<_, _, ()>(keys::user::party(leader_id), party_id.to_string())
            .await
            .context("Failed to set user party in Redis")
        {
            // best-effort rollback of party keys (same slot, so safe)
            let mut pipe = redis::pipe();
            pipe.del(&info_key).ignore().del(&members_key).ignore();
            let _: std::result::Result<(), _> = pipe.query_async(&mut conn).await;
            return Err(e.context("Failed to assign leader to party; rolled back party creation"));
        }
        Ok(())
    }

    pub async fn get_info(&self, party_id: Uuid) -> Result<Option<PartyInfo>> {
        let info_key = keys::party::info(party_id);
        let members_key = keys::party::members(party_id);
        let script = redis::Script::new(scripts::GET_PARTY);
        let mut conn = self
            .pool
            .get()
            .await
            .context("Failed to get Redis connection")?;
        let raw: Option<Vec<String>> = script
            .key(&info_key)
            .key(&members_key)
            .arg(EXPIRE_SECONDS)
            .invoke_async(&mut conn)
            .await
            .context("Failed to invoke Redis script to get party info")?;
        // raw == None means "not found"
        let Some(mut raw) = raw else {
            return Ok(None);
        };
        let leader = raw.remove(0);
        let name = raw.remove(0);
        let name = if name.is_empty() { None } else { Some(name) };
        let leader = Uuid::parse_str(&leader).context("Failed to parse leader UUID")?;
        let members = raw
            .into_iter()
            .filter_map(|s| Uuid::parse_str(&s).ok())
            .collect();
        Ok(Some(PartyInfo {
            id: party_id,
            name,
            leader,
            members,
        }))
    }

    async fn set_field(&self, party_id: Uuid, field: &str, value: String) -> Result<()> {
        let key = keys::party::info(party_id);
        let _: () = redis::pipe()
            .hset(&key, field, value)
            .ignore()
            .expire(&key, EXPIRE_SECONDS)
            .ignore()
            .query_async(
                &mut self
                    .pool
                    .get()
                    .await
                    .context("Failed to get Redis connection")?,
            )
            .await?;
        Ok(())
    }

    pub async fn set_name(&self, party_id: Uuid, name: String) -> Result<()> {
        self.set_field(party_id, "name", name).await
    }

    pub async fn set_leader(&self, party_id: Uuid, leader_id: Uuid) -> Result<()> {
        self.set_field(party_id, "leader", leader_id.to_string())
            .await
    }

    pub async fn add_member(&self, party_id: Uuid, user_id: Uuid) -> Result<()> {
        let user_party_key = keys::user::party(user_id);
        let mut conn: deadpool_redis::Connection = self
            .pool
            .get()
            .await
            .context("Failed to get Redis connection")?;
        let old_party_id: Option<Uuid> = conn
            .get::<_, Option<String>>(&user_party_key)
            .await
            .context("Failed to get old_party_id from Redis")?
            .map(|s: String| Uuid::parse_str(&s))
            .transpose()
            .inspect_err(|e| {
                eprintln!(
                    "{}{}{}{}",
                    "âš ï¸ Failed to parse old_party_id UUID for user ".yellow(),
                    user_id.yellow().dimmed(),
                    ": ".yellow(),
                    format!("{:?}", e).yellow().dimmed()
                );
            })
            .unwrap_or_default();
        if let Some(old_party_id) = old_party_id {
            self.remove_member_inner(old_party_id, user_id, &mut conn)
                .await
                .context("Failed to remove user from old party before adding to new party")?;
        }
        let members_key = keys::party::members(party_id);
        let _: () = redis::pipe()
            .sadd(&members_key, user_id.to_string())
            .expire(&members_key, EXPIRE_SECONDS)
            .query_async(&mut conn)
            .await
            .context("Failed to add member to Redis set")?;
        let _: () = conn
            .set_ex(&user_party_key, party_id.to_string(), EXPIRE_SECONDS as u64)
            .await
            .context("Failed to set user party in Redis")?;
        Ok(())
    }

    pub async fn remove_member(&self, party_id: Uuid, user_id: Uuid) -> Result<()> {
        let mut conn = self
            .pool
            .get()
            .await
            .context("Failed to get Redis connection")?;
        self.remove_member_inner(party_id, user_id, &mut conn).await
    }

    pub async fn remove_member_inner(
        &self,
        party_id: Uuid,
        user_id: Uuid,
        conn: &mut deadpool_redis::Connection,
    ) -> Result<()> {
        let script = redis::Script::new(scripts::REMOVE_MEMBER);
        let remaining: i64 = script
            .key(keys::party::members(party_id))
            .key(keys::party::info(party_id))
            .arg(user_id.to_string())
            .invoke_async(conn)
            .await
            .context("Failed to invoke Redis script to remove member")?;
        if remaining == 0 {
            println!(
                "{}{}",
                "ðŸ—‘ï¸ Disposed of party ".cyan(),
                party_id.to_string().cyan().dimmed()
            );
        }
        Ok(())
    }
}

pub(crate) mod keys {
    pub mod user {
        use uuid::Uuid;

        pub fn party(user_id: Uuid) -> String {
            format!("user_id:{{{}}}:party", user_id)
        }
    }

    pub mod party {
        use uuid::Uuid;

        pub fn info(party_id: Uuid) -> String {
            format!("party:{{{}}}:info", party_id)
        }

        pub fn members(party_id: Uuid) -> String {
            format!("party:{{{}}}:members", party_id)
        }
    }
}