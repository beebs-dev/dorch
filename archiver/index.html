<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Doom Panorama Viewer</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        background: #000;
        overflow: hidden;
        touch-action: none; /* important for mobile dragging */
      }
      #c {
        display: block;
        width: 100vw;
        height: 100vh;
        cursor: grab;
      }
      #c:active { cursor: grabbing; }

      .hud {
        position: fixed;
        left: 12px;
        bottom: 10px;
        padding: 8px 10px;
        font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        color: rgba(255,255,255,0.9);
        background: rgba(0,0,0,0.55);
        border-radius: 10px;
        max-width: min(560px, calc(100vw - 24px));
      }
      .hud code { color: rgba(255,255,255,0.95); }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div class="hud">
      Drag to look around • Wheel to zoom • Double-click to reset<br/>
      Image: <code id="imgPath"></code>
    </div>

    <!-- Three.js (module) -->
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

      // >>> CHANGE THIS PATH <<<
      const PANORAMA_URL = "https://wadimages2.nyc3.digitaloceanspaces.com/a64312399a2d6cba0c322f859c5d946488dd33e6/MAP01/pano/pano_0.jpg";
      document.getElementById("imgPath").textContent = PANORAMA_URL;

      const canvas = document.getElementById("c");

      // Renderer
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

      // Scene + Camera
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 2000);
      camera.position.set(0, 0, 0.01); // inside the sphere

      // Controls (click+drag look)
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = false;          // no panning (feels like Street View)
      controls.rotateSpeed = 0.35;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;

      // Clamp vertical look to +/- 10 degrees (keep full horizontal freedom)
      const PITCH_LIMIT_DEG = 10;
      const pitchLimit = THREE.MathUtils.degToRad(PITCH_LIMIT_DEG);
      const horizon = Math.PI / 2;
      controls.minPolarAngle = horizon - pitchLimit;
      controls.maxPolarAngle = horizon + pitchLimit;

      // Optional: zoom
      controls.enableZoom = true;          // set false to disable wheel zoom
      controls.minDistance = 0.01;
      controls.maxDistance = 0.01;         // keep camera at same "radius"
      // Note: we "zoom" by changing FOV instead, see wheel handler below.

      // Use FOV zoom like Street View
      const DEFAULT_FOV = 75;
      camera.fov = DEFAULT_FOV;
      camera.updateProjectionMatrix();

      // Texture loader
      async function webpUrlToPngObjectUrl(webpUrl) {
        const response = await fetch(webpUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch WEBP (${response.status}): ${webpUrl}`);
        }
        const webpBlob = await response.blob();

        // Decode the image (prefer createImageBitmap; fall back to <img>.decode()).
        let bitmap;
        try {
          bitmap = await createImageBitmap(webpBlob);
        } catch {
          const webpObjectUrl = URL.createObjectURL(webpBlob);
          try {
            const img = new Image();
            img.decoding = "async";
            img.src = webpObjectUrl;
            if (img.decode) {
              await img.decode();
            } else {
              await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
              });
            }
            bitmap = img;
          } finally {
            URL.revokeObjectURL(webpObjectUrl);
          }
        }

        const canvas = document.createElement("canvas");
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        const ctx = canvas.getContext("2d", { alpha: false });
        if (!ctx) {
          throw new Error("Failed to get 2D canvas context for WEBP->PNG conversion");
        }
        ctx.drawImage(bitmap, 0, 0);

        const pngBlob = await new Promise((resolve, reject) => {
          canvas.toBlob((b) => (b ? resolve(b) : reject(new Error("canvas.toBlob returned null"))), "image/png");
        });

        // If bitmap was an ImageBitmap, free its resources.
        if (bitmap && typeof bitmap.close === "function") {
          bitmap.close();
        }

        return URL.createObjectURL(pngBlob);
      }

      const loader = new THREE.TextureLoader();
      (async () => {
        let pngObjectUrl;
        try {
          pngObjectUrl = await webpUrlToPngObjectUrl(PANORAMA_URL);
          const texture = await loader.loadAsync(pngObjectUrl);

          texture.colorSpace = THREE.SRGBColorSpace;
          texture.wrapS = THREE.RepeatWrapping;
          texture.repeat.x = -1;
          texture.flipY = false;
          texture.needsUpdate = true;

          // Create sphere and map the panorama on the INSIDE
          const geometry = new THREE.SphereGeometry(500, 64, 32);
          geometry.scale(-1, 1, 1); // invert the sphere to face inward

          const material = new THREE.MeshBasicMaterial({ map: texture });
          const mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);
        } catch (err) {
          console.error("Failed to load panorama:", err);
          alert("Failed to load panorama. Check the PANORAMA_URL path and that you're serving via a local web server.");
        } finally {
          if (pngObjectUrl) URL.revokeObjectURL(pngObjectUrl);
        }
      })();

      // Resize handling
      function resizeRendererToDisplaySize() {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const needResize = canvas.width !== Math.floor(w * renderer.getPixelRatio()) ||
                           canvas.height !== Math.floor(h * renderer.getPixelRatio());
        if (needResize) {
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        }
      }

      // Wheel-to-zoom via FOV (more Street View-like)
      window.addEventListener("wheel", (e) => {
        // If you want NO scroll-wheel zoom, comment out this whole handler.
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        camera.fov = THREE.MathUtils.clamp(camera.fov + delta * 2.5, 35, 95);
        camera.updateProjectionMatrix();
      }, { passive: false });

      // Double click to reset view
      window.addEventListener("dblclick", () => {
        controls.reset();
        camera.fov = DEFAULT_FOV;
        camera.updateProjectionMatrix();
      });

      // Animation loop
      function animate() {
        resizeRendererToDisplaySize();
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
